#pragma kernel VolumeCloud

cbuffer Consts
{
    uint Resolution;
}

uint PackColor(float4 color)
{
    color = saturate(color);
    return uint(color.a * 255.5f) << 24 | uint(color.b * 255.5f) << 16 | uint(color.g * 255.5f) << 8 | uint(color.r * 255.5f);
}

struct Ray
{
    float3 origin;
    float3 direction;
};

float DistanceToSphere(const float3 p, const float3 center, const float radius)
{
    return distance(p, center) - radius;
}

float DistanceToCube(const float3 p, const float3 center, const float3 extent)
{
    const float3 q = abs(p - center) - extent;
    return length(max(q.xyz, 0.0f)) + min(max(max(q.x, q.y), q.z), 0.0f);
}
         
float SDFVolume(float3 p)
{
    const float ds = DistanceToSphere(p, float3(-0.2f, 0.0f, 0.0f), 0.4f);
    const float dc = DistanceToCube(p, float3(0.2f, 0.0f, 0.0f), float3(0.3f, 0.2f, 0.3f));
    return min(ds, dc);
}

float VolumeMarch(Ray ray)
{
    float t = 0.0f;
    float acc = 0.0f;
    for (int i = 0; i < 128; ++i)
    {
        float3 p = mad(ray.direction, t, ray.origin);
        float d = SDFVolume(p);
        if (d < 0.0f) { acc += 0.03f; }
        t += 0.01f;
    }

    return acc;
}

uniform float Angle;

RWByteAddressBuffer buffer;

[numthreads(8, 8, 1)]
void VolumeCloud(const uint2 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution || id.y >= Resolution) { return; }

    float3 origin = float3(mad(float2(id.xy) / Resolution.xx, 2.0f, -1.0f), 0.0f);
    float3 forward = float3(0.0f, 0.0f, 1.0f);

    float2 sc;
    sincos(Angle, sc.x, sc.y);
    float2x2 rotations = float2x2(sc.x, sc.y, -sc.y, sc.x);
    origin.xz = mul(rotations, origin.xz);
    forward.xz = mul(rotations, forward.xz);
    
    Ray ray;
    ray.origin = origin;
    ray.direction = forward;
    const float t = VolumeMarch(ray);
    
    float4 color = float4(t, t, t, t);
    uint colorPacked = PackColor(color);
    buffer.Store(id.x + id.y * Resolution << 2, colorPacked);
}